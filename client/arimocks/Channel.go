// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package arimocks

import (
	"time"

	"github.com/CyCoreSystems/ari/v6"
	mock "github.com/stretchr/testify/mock"
)

// NewChannel creates a new instance of Channel. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewChannel(t interface {
	mock.TestingT
	Cleanup(func())
}) *Channel {
	mock := &Channel{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Channel is an autogenerated mock type for the Channel type
type Channel struct {
	mock.Mock
}

type Channel_Expecter struct {
	mock *mock.Mock
}

func (_m *Channel) EXPECT() *Channel_Expecter {
	return &Channel_Expecter{mock: &_m.Mock}
}

// Answer provides a mock function for the type Channel
func (_mock *Channel) Answer(key *ari.Key) error {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Answer")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key) error); ok {
		r0 = returnFunc(key)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Channel_Answer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Answer'
type Channel_Answer_Call struct {
	*mock.Call
}

// Answer is a helper method to define mock.On call
//   - key *ari.Key
func (_e *Channel_Expecter) Answer(key interface{}) *Channel_Answer_Call {
	return &Channel_Answer_Call{Call: _e.mock.On("Answer", key)}
}

func (_c *Channel_Answer_Call) Run(run func(key *ari.Key)) *Channel_Answer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Channel_Answer_Call) Return(err error) *Channel_Answer_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Channel_Answer_Call) RunAndReturn(run func(key *ari.Key) error) *Channel_Answer_Call {
	_c.Call.Return(run)
	return _c
}

// Busy provides a mock function for the type Channel
func (_mock *Channel) Busy(key *ari.Key) error {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Busy")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key) error); ok {
		r0 = returnFunc(key)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Channel_Busy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Busy'
type Channel_Busy_Call struct {
	*mock.Call
}

// Busy is a helper method to define mock.On call
//   - key *ari.Key
func (_e *Channel_Expecter) Busy(key interface{}) *Channel_Busy_Call {
	return &Channel_Busy_Call{Call: _e.mock.On("Busy", key)}
}

func (_c *Channel_Busy_Call) Run(run func(key *ari.Key)) *Channel_Busy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Channel_Busy_Call) Return(err error) *Channel_Busy_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Channel_Busy_Call) RunAndReturn(run func(key *ari.Key) error) *Channel_Busy_Call {
	_c.Call.Return(run)
	return _c
}

// Congestion provides a mock function for the type Channel
func (_mock *Channel) Congestion(key *ari.Key) error {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Congestion")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key) error); ok {
		r0 = returnFunc(key)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Channel_Congestion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Congestion'
type Channel_Congestion_Call struct {
	*mock.Call
}

// Congestion is a helper method to define mock.On call
//   - key *ari.Key
func (_e *Channel_Expecter) Congestion(key interface{}) *Channel_Congestion_Call {
	return &Channel_Congestion_Call{Call: _e.mock.On("Congestion", key)}
}

func (_c *Channel_Congestion_Call) Run(run func(key *ari.Key)) *Channel_Congestion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Channel_Congestion_Call) Return(err error) *Channel_Congestion_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Channel_Congestion_Call) RunAndReturn(run func(key *ari.Key) error) *Channel_Congestion_Call {
	_c.Call.Return(run)
	return _c
}

// Continue provides a mock function for the type Channel
func (_mock *Channel) Continue(key *ari.Key, context string, extension string, priority int) error {
	ret := _mock.Called(key, context, extension, priority)

	if len(ret) == 0 {
		panic("no return value specified for Continue")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, string, string, int) error); ok {
		r0 = returnFunc(key, context, extension, priority)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Channel_Continue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Continue'
type Channel_Continue_Call struct {
	*mock.Call
}

// Continue is a helper method to define mock.On call
//   - key *ari.Key
//   - context string
//   - extension string
//   - priority int
func (_e *Channel_Expecter) Continue(key interface{}, context interface{}, extension interface{}, priority interface{}) *Channel_Continue_Call {
	return &Channel_Continue_Call{Call: _e.mock.On("Continue", key, context, extension, priority)}
}

func (_c *Channel_Continue_Call) Run(run func(key *ari.Key, context string, extension string, priority int)) *Channel_Continue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *Channel_Continue_Call) Return(err error) *Channel_Continue_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Channel_Continue_Call) RunAndReturn(run func(key *ari.Key, context string, extension string, priority int) error) *Channel_Continue_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function for the type Channel
func (_mock *Channel) Create(key *ari.Key, channelCreateRequest ari.ChannelCreateRequest) (*ari.ChannelHandle, error) {
	ret := _mock.Called(key, channelCreateRequest)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *ari.ChannelHandle
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, ari.ChannelCreateRequest) (*ari.ChannelHandle, error)); ok {
		return returnFunc(key, channelCreateRequest)
	}
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, ari.ChannelCreateRequest) *ari.ChannelHandle); ok {
		r0 = returnFunc(key, channelCreateRequest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ari.ChannelHandle)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*ari.Key, ari.ChannelCreateRequest) error); ok {
		r1 = returnFunc(key, channelCreateRequest)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Channel_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type Channel_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - key *ari.Key
//   - channelCreateRequest ari.ChannelCreateRequest
func (_e *Channel_Expecter) Create(key interface{}, channelCreateRequest interface{}) *Channel_Create_Call {
	return &Channel_Create_Call{Call: _e.mock.On("Create", key, channelCreateRequest)}
}

func (_c *Channel_Create_Call) Run(run func(key *ari.Key, channelCreateRequest ari.ChannelCreateRequest)) *Channel_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		var arg1 ari.ChannelCreateRequest
		if args[1] != nil {
			arg1 = args[1].(ari.ChannelCreateRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Channel_Create_Call) Return(channelHandle *ari.ChannelHandle, err error) *Channel_Create_Call {
	_c.Call.Return(channelHandle, err)
	return _c
}

func (_c *Channel_Create_Call) RunAndReturn(run func(key *ari.Key, channelCreateRequest ari.ChannelCreateRequest) (*ari.ChannelHandle, error)) *Channel_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Data provides a mock function for the type Channel
func (_mock *Channel) Data(key *ari.Key) (*ari.ChannelData, error) {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Data")
	}

	var r0 *ari.ChannelData
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key) (*ari.ChannelData, error)); ok {
		return returnFunc(key)
	}
	if returnFunc, ok := ret.Get(0).(func(*ari.Key) *ari.ChannelData); ok {
		r0 = returnFunc(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ari.ChannelData)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*ari.Key) error); ok {
		r1 = returnFunc(key)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Channel_Data_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Data'
type Channel_Data_Call struct {
	*mock.Call
}

// Data is a helper method to define mock.On call
//   - key *ari.Key
func (_e *Channel_Expecter) Data(key interface{}) *Channel_Data_Call {
	return &Channel_Data_Call{Call: _e.mock.On("Data", key)}
}

func (_c *Channel_Data_Call) Run(run func(key *ari.Key)) *Channel_Data_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Channel_Data_Call) Return(channelData *ari.ChannelData, err error) *Channel_Data_Call {
	_c.Call.Return(channelData, err)
	return _c
}

func (_c *Channel_Data_Call) RunAndReturn(run func(key *ari.Key) (*ari.ChannelData, error)) *Channel_Data_Call {
	_c.Call.Return(run)
	return _c
}

// Dial provides a mock function for the type Channel
func (_mock *Channel) Dial(key *ari.Key, caller string, timeout time.Duration) error {
	ret := _mock.Called(key, caller, timeout)

	if len(ret) == 0 {
		panic("no return value specified for Dial")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, string, time.Duration) error); ok {
		r0 = returnFunc(key, caller, timeout)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Channel_Dial_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Dial'
type Channel_Dial_Call struct {
	*mock.Call
}

// Dial is a helper method to define mock.On call
//   - key *ari.Key
//   - caller string
//   - timeout time.Duration
func (_e *Channel_Expecter) Dial(key interface{}, caller interface{}, timeout interface{}) *Channel_Dial_Call {
	return &Channel_Dial_Call{Call: _e.mock.On("Dial", key, caller, timeout)}
}

func (_c *Channel_Dial_Call) Run(run func(key *ari.Key, caller string, timeout time.Duration)) *Channel_Dial_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 time.Duration
		if args[2] != nil {
			arg2 = args[2].(time.Duration)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Channel_Dial_Call) Return(err error) *Channel_Dial_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Channel_Dial_Call) RunAndReturn(run func(key *ari.Key, caller string, timeout time.Duration) error) *Channel_Dial_Call {
	_c.Call.Return(run)
	return _c
}

// ExternalMedia provides a mock function for the type Channel
func (_mock *Channel) ExternalMedia(key *ari.Key, opts ari.ExternalMediaOptions) (*ari.ChannelHandle, error) {
	ret := _mock.Called(key, opts)

	if len(ret) == 0 {
		panic("no return value specified for ExternalMedia")
	}

	var r0 *ari.ChannelHandle
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, ari.ExternalMediaOptions) (*ari.ChannelHandle, error)); ok {
		return returnFunc(key, opts)
	}
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, ari.ExternalMediaOptions) *ari.ChannelHandle); ok {
		r0 = returnFunc(key, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ari.ChannelHandle)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*ari.Key, ari.ExternalMediaOptions) error); ok {
		r1 = returnFunc(key, opts)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Channel_ExternalMedia_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExternalMedia'
type Channel_ExternalMedia_Call struct {
	*mock.Call
}

// ExternalMedia is a helper method to define mock.On call
//   - key *ari.Key
//   - opts ari.ExternalMediaOptions
func (_e *Channel_Expecter) ExternalMedia(key interface{}, opts interface{}) *Channel_ExternalMedia_Call {
	return &Channel_ExternalMedia_Call{Call: _e.mock.On("ExternalMedia", key, opts)}
}

func (_c *Channel_ExternalMedia_Call) Run(run func(key *ari.Key, opts ari.ExternalMediaOptions)) *Channel_ExternalMedia_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		var arg1 ari.ExternalMediaOptions
		if args[1] != nil {
			arg1 = args[1].(ari.ExternalMediaOptions)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Channel_ExternalMedia_Call) Return(channelHandle *ari.ChannelHandle, err error) *Channel_ExternalMedia_Call {
	_c.Call.Return(channelHandle, err)
	return _c
}

func (_c *Channel_ExternalMedia_Call) RunAndReturn(run func(key *ari.Key, opts ari.ExternalMediaOptions) (*ari.ChannelHandle, error)) *Channel_ExternalMedia_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type Channel
func (_mock *Channel) Get(key *ari.Key) *ari.ChannelHandle {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *ari.ChannelHandle
	if returnFunc, ok := ret.Get(0).(func(*ari.Key) *ari.ChannelHandle); ok {
		r0 = returnFunc(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ari.ChannelHandle)
		}
	}
	return r0
}

// Channel_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type Channel_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - key *ari.Key
func (_e *Channel_Expecter) Get(key interface{}) *Channel_Get_Call {
	return &Channel_Get_Call{Call: _e.mock.On("Get", key)}
}

func (_c *Channel_Get_Call) Run(run func(key *ari.Key)) *Channel_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Channel_Get_Call) Return(channelHandle *ari.ChannelHandle) *Channel_Get_Call {
	_c.Call.Return(channelHandle)
	return _c
}

func (_c *Channel_Get_Call) RunAndReturn(run func(key *ari.Key) *ari.ChannelHandle) *Channel_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetVariable provides a mock function for the type Channel
func (_mock *Channel) GetVariable(key *ari.Key, s string) (string, error) {
	ret := _mock.Called(key, s)

	if len(ret) == 0 {
		panic("no return value specified for GetVariable")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, string) (string, error)); ok {
		return returnFunc(key, s)
	}
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, string) string); ok {
		r0 = returnFunc(key, s)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(*ari.Key, string) error); ok {
		r1 = returnFunc(key, s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Channel_GetVariable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVariable'
type Channel_GetVariable_Call struct {
	*mock.Call
}

// GetVariable is a helper method to define mock.On call
//   - key *ari.Key
//   - s string
func (_e *Channel_Expecter) GetVariable(key interface{}, s interface{}) *Channel_GetVariable_Call {
	return &Channel_GetVariable_Call{Call: _e.mock.On("GetVariable", key, s)}
}

func (_c *Channel_GetVariable_Call) Run(run func(key *ari.Key, s string)) *Channel_GetVariable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Channel_GetVariable_Call) Return(s1 string, err error) *Channel_GetVariable_Call {
	_c.Call.Return(s1, err)
	return _c
}

func (_c *Channel_GetVariable_Call) RunAndReturn(run func(key *ari.Key, s string) (string, error)) *Channel_GetVariable_Call {
	_c.Call.Return(run)
	return _c
}

// Hangup provides a mock function for the type Channel
func (_mock *Channel) Hangup(key *ari.Key, reason string) error {
	ret := _mock.Called(key, reason)

	if len(ret) == 0 {
		panic("no return value specified for Hangup")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, string) error); ok {
		r0 = returnFunc(key, reason)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Channel_Hangup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Hangup'
type Channel_Hangup_Call struct {
	*mock.Call
}

// Hangup is a helper method to define mock.On call
//   - key *ari.Key
//   - reason string
func (_e *Channel_Expecter) Hangup(key interface{}, reason interface{}) *Channel_Hangup_Call {
	return &Channel_Hangup_Call{Call: _e.mock.On("Hangup", key, reason)}
}

func (_c *Channel_Hangup_Call) Run(run func(key *ari.Key, reason string)) *Channel_Hangup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Channel_Hangup_Call) Return(err error) *Channel_Hangup_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Channel_Hangup_Call) RunAndReturn(run func(key *ari.Key, reason string) error) *Channel_Hangup_Call {
	_c.Call.Return(run)
	return _c
}

// Hold provides a mock function for the type Channel
func (_mock *Channel) Hold(key *ari.Key) error {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Hold")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key) error); ok {
		r0 = returnFunc(key)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Channel_Hold_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Hold'
type Channel_Hold_Call struct {
	*mock.Call
}

// Hold is a helper method to define mock.On call
//   - key *ari.Key
func (_e *Channel_Expecter) Hold(key interface{}) *Channel_Hold_Call {
	return &Channel_Hold_Call{Call: _e.mock.On("Hold", key)}
}

func (_c *Channel_Hold_Call) Run(run func(key *ari.Key)) *Channel_Hold_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Channel_Hold_Call) Return(err error) *Channel_Hold_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Channel_Hold_Call) RunAndReturn(run func(key *ari.Key) error) *Channel_Hold_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type Channel
func (_mock *Channel) List(key *ari.Key) ([]*ari.Key, error) {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 []*ari.Key
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key) ([]*ari.Key, error)); ok {
		return returnFunc(key)
	}
	if returnFunc, ok := ret.Get(0).(func(*ari.Key) []*ari.Key); ok {
		r0 = returnFunc(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ari.Key)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*ari.Key) error); ok {
		r1 = returnFunc(key)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Channel_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type Channel_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - key *ari.Key
func (_e *Channel_Expecter) List(key interface{}) *Channel_List_Call {
	return &Channel_List_Call{Call: _e.mock.On("List", key)}
}

func (_c *Channel_List_Call) Run(run func(key *ari.Key)) *Channel_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Channel_List_Call) Return(keys []*ari.Key, err error) *Channel_List_Call {
	_c.Call.Return(keys, err)
	return _c
}

func (_c *Channel_List_Call) RunAndReturn(run func(key *ari.Key) ([]*ari.Key, error)) *Channel_List_Call {
	_c.Call.Return(run)
	return _c
}

// MOH provides a mock function for the type Channel
func (_mock *Channel) MOH(key *ari.Key, moh string) error {
	ret := _mock.Called(key, moh)

	if len(ret) == 0 {
		panic("no return value specified for MOH")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, string) error); ok {
		r0 = returnFunc(key, moh)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Channel_MOH_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MOH'
type Channel_MOH_Call struct {
	*mock.Call
}

// MOH is a helper method to define mock.On call
//   - key *ari.Key
//   - moh string
func (_e *Channel_Expecter) MOH(key interface{}, moh interface{}) *Channel_MOH_Call {
	return &Channel_MOH_Call{Call: _e.mock.On("MOH", key, moh)}
}

func (_c *Channel_MOH_Call) Run(run func(key *ari.Key, moh string)) *Channel_MOH_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Channel_MOH_Call) Return(err error) *Channel_MOH_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Channel_MOH_Call) RunAndReturn(run func(key *ari.Key, moh string) error) *Channel_MOH_Call {
	_c.Call.Return(run)
	return _c
}

// Move provides a mock function for the type Channel
func (_mock *Channel) Move(key *ari.Key, app string, appArgs string) error {
	ret := _mock.Called(key, app, appArgs)

	if len(ret) == 0 {
		panic("no return value specified for Move")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, string, string) error); ok {
		r0 = returnFunc(key, app, appArgs)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Channel_Move_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Move'
type Channel_Move_Call struct {
	*mock.Call
}

// Move is a helper method to define mock.On call
//   - key *ari.Key
//   - app string
//   - appArgs string
func (_e *Channel_Expecter) Move(key interface{}, app interface{}, appArgs interface{}) *Channel_Move_Call {
	return &Channel_Move_Call{Call: _e.mock.On("Move", key, app, appArgs)}
}

func (_c *Channel_Move_Call) Run(run func(key *ari.Key, app string, appArgs string)) *Channel_Move_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Channel_Move_Call) Return(err error) *Channel_Move_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Channel_Move_Call) RunAndReturn(run func(key *ari.Key, app string, appArgs string) error) *Channel_Move_Call {
	_c.Call.Return(run)
	return _c
}

// Mute provides a mock function for the type Channel
func (_mock *Channel) Mute(key *ari.Key, dir ari.Direction) error {
	ret := _mock.Called(key, dir)

	if len(ret) == 0 {
		panic("no return value specified for Mute")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, ari.Direction) error); ok {
		r0 = returnFunc(key, dir)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Channel_Mute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Mute'
type Channel_Mute_Call struct {
	*mock.Call
}

// Mute is a helper method to define mock.On call
//   - key *ari.Key
//   - dir ari.Direction
func (_e *Channel_Expecter) Mute(key interface{}, dir interface{}) *Channel_Mute_Call {
	return &Channel_Mute_Call{Call: _e.mock.On("Mute", key, dir)}
}

func (_c *Channel_Mute_Call) Run(run func(key *ari.Key, dir ari.Direction)) *Channel_Mute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		var arg1 ari.Direction
		if args[1] != nil {
			arg1 = args[1].(ari.Direction)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Channel_Mute_Call) Return(err error) *Channel_Mute_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Channel_Mute_Call) RunAndReturn(run func(key *ari.Key, dir ari.Direction) error) *Channel_Mute_Call {
	_c.Call.Return(run)
	return _c
}

// Originate provides a mock function for the type Channel
func (_mock *Channel) Originate(key *ari.Key, originateRequest ari.OriginateRequest) (*ari.ChannelHandle, error) {
	ret := _mock.Called(key, originateRequest)

	if len(ret) == 0 {
		panic("no return value specified for Originate")
	}

	var r0 *ari.ChannelHandle
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, ari.OriginateRequest) (*ari.ChannelHandle, error)); ok {
		return returnFunc(key, originateRequest)
	}
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, ari.OriginateRequest) *ari.ChannelHandle); ok {
		r0 = returnFunc(key, originateRequest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ari.ChannelHandle)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*ari.Key, ari.OriginateRequest) error); ok {
		r1 = returnFunc(key, originateRequest)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Channel_Originate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Originate'
type Channel_Originate_Call struct {
	*mock.Call
}

// Originate is a helper method to define mock.On call
//   - key *ari.Key
//   - originateRequest ari.OriginateRequest
func (_e *Channel_Expecter) Originate(key interface{}, originateRequest interface{}) *Channel_Originate_Call {
	return &Channel_Originate_Call{Call: _e.mock.On("Originate", key, originateRequest)}
}

func (_c *Channel_Originate_Call) Run(run func(key *ari.Key, originateRequest ari.OriginateRequest)) *Channel_Originate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		var arg1 ari.OriginateRequest
		if args[1] != nil {
			arg1 = args[1].(ari.OriginateRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Channel_Originate_Call) Return(channelHandle *ari.ChannelHandle, err error) *Channel_Originate_Call {
	_c.Call.Return(channelHandle, err)
	return _c
}

func (_c *Channel_Originate_Call) RunAndReturn(run func(key *ari.Key, originateRequest ari.OriginateRequest) (*ari.ChannelHandle, error)) *Channel_Originate_Call {
	_c.Call.Return(run)
	return _c
}

// Play provides a mock function for the type Channel
func (_mock *Channel) Play(key *ari.Key, playbackID string, mediaURI ...string) (*ari.PlaybackHandle, error) {
	// string
	_va := make([]interface{}, len(mediaURI))
	for _i := range mediaURI {
		_va[_i] = mediaURI[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key, playbackID)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Play")
	}

	var r0 *ari.PlaybackHandle
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, string, ...string) (*ari.PlaybackHandle, error)); ok {
		return returnFunc(key, playbackID, mediaURI...)
	}
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, string, ...string) *ari.PlaybackHandle); ok {
		r0 = returnFunc(key, playbackID, mediaURI...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ari.PlaybackHandle)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*ari.Key, string, ...string) error); ok {
		r1 = returnFunc(key, playbackID, mediaURI...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Channel_Play_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Play'
type Channel_Play_Call struct {
	*mock.Call
}

// Play is a helper method to define mock.On call
//   - key *ari.Key
//   - playbackID string
//   - mediaURI ...string
func (_e *Channel_Expecter) Play(key interface{}, playbackID interface{}, mediaURI ...interface{}) *Channel_Play_Call {
	return &Channel_Play_Call{Call: _e.mock.On("Play",
		append([]interface{}{key, playbackID}, mediaURI...)...)}
}

func (_c *Channel_Play_Call) Run(run func(key *ari.Key, playbackID string, mediaURI ...string)) *Channel_Play_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []string
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *Channel_Play_Call) Return(playbackHandle *ari.PlaybackHandle, err error) *Channel_Play_Call {
	_c.Call.Return(playbackHandle, err)
	return _c
}

func (_c *Channel_Play_Call) RunAndReturn(run func(key *ari.Key, playbackID string, mediaURI ...string) (*ari.PlaybackHandle, error)) *Channel_Play_Call {
	_c.Call.Return(run)
	return _c
}

// Record provides a mock function for the type Channel
func (_mock *Channel) Record(key *ari.Key, name string, opts *ari.RecordingOptions) (*ari.LiveRecordingHandle, error) {
	ret := _mock.Called(key, name, opts)

	if len(ret) == 0 {
		panic("no return value specified for Record")
	}

	var r0 *ari.LiveRecordingHandle
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, string, *ari.RecordingOptions) (*ari.LiveRecordingHandle, error)); ok {
		return returnFunc(key, name, opts)
	}
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, string, *ari.RecordingOptions) *ari.LiveRecordingHandle); ok {
		r0 = returnFunc(key, name, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ari.LiveRecordingHandle)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*ari.Key, string, *ari.RecordingOptions) error); ok {
		r1 = returnFunc(key, name, opts)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Channel_Record_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Record'
type Channel_Record_Call struct {
	*mock.Call
}

// Record is a helper method to define mock.On call
//   - key *ari.Key
//   - name string
//   - opts *ari.RecordingOptions
func (_e *Channel_Expecter) Record(key interface{}, name interface{}, opts interface{}) *Channel_Record_Call {
	return &Channel_Record_Call{Call: _e.mock.On("Record", key, name, opts)}
}

func (_c *Channel_Record_Call) Run(run func(key *ari.Key, name string, opts *ari.RecordingOptions)) *Channel_Record_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 *ari.RecordingOptions
		if args[2] != nil {
			arg2 = args[2].(*ari.RecordingOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Channel_Record_Call) Return(liveRecordingHandle *ari.LiveRecordingHandle, err error) *Channel_Record_Call {
	_c.Call.Return(liveRecordingHandle, err)
	return _c
}

func (_c *Channel_Record_Call) RunAndReturn(run func(key *ari.Key, name string, opts *ari.RecordingOptions) (*ari.LiveRecordingHandle, error)) *Channel_Record_Call {
	_c.Call.Return(run)
	return _c
}

// Ring provides a mock function for the type Channel
func (_mock *Channel) Ring(key *ari.Key) error {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Ring")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key) error); ok {
		r0 = returnFunc(key)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Channel_Ring_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ring'
type Channel_Ring_Call struct {
	*mock.Call
}

// Ring is a helper method to define mock.On call
//   - key *ari.Key
func (_e *Channel_Expecter) Ring(key interface{}) *Channel_Ring_Call {
	return &Channel_Ring_Call{Call: _e.mock.On("Ring", key)}
}

func (_c *Channel_Ring_Call) Run(run func(key *ari.Key)) *Channel_Ring_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Channel_Ring_Call) Return(err error) *Channel_Ring_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Channel_Ring_Call) RunAndReturn(run func(key *ari.Key) error) *Channel_Ring_Call {
	_c.Call.Return(run)
	return _c
}

// SendDTMF provides a mock function for the type Channel
func (_mock *Channel) SendDTMF(key *ari.Key, dtmf string, opts *ari.DTMFOptions) error {
	ret := _mock.Called(key, dtmf, opts)

	if len(ret) == 0 {
		panic("no return value specified for SendDTMF")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, string, *ari.DTMFOptions) error); ok {
		r0 = returnFunc(key, dtmf, opts)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Channel_SendDTMF_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendDTMF'
type Channel_SendDTMF_Call struct {
	*mock.Call
}

// SendDTMF is a helper method to define mock.On call
//   - key *ari.Key
//   - dtmf string
//   - opts *ari.DTMFOptions
func (_e *Channel_Expecter) SendDTMF(key interface{}, dtmf interface{}, opts interface{}) *Channel_SendDTMF_Call {
	return &Channel_SendDTMF_Call{Call: _e.mock.On("SendDTMF", key, dtmf, opts)}
}

func (_c *Channel_SendDTMF_Call) Run(run func(key *ari.Key, dtmf string, opts *ari.DTMFOptions)) *Channel_SendDTMF_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 *ari.DTMFOptions
		if args[2] != nil {
			arg2 = args[2].(*ari.DTMFOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Channel_SendDTMF_Call) Return(err error) *Channel_SendDTMF_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Channel_SendDTMF_Call) RunAndReturn(run func(key *ari.Key, dtmf string, opts *ari.DTMFOptions) error) *Channel_SendDTMF_Call {
	_c.Call.Return(run)
	return _c
}

// SetVariable provides a mock function for the type Channel
func (_mock *Channel) SetVariable(key *ari.Key, name string, value string) error {
	ret := _mock.Called(key, name, value)

	if len(ret) == 0 {
		panic("no return value specified for SetVariable")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, string, string) error); ok {
		r0 = returnFunc(key, name, value)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Channel_SetVariable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetVariable'
type Channel_SetVariable_Call struct {
	*mock.Call
}

// SetVariable is a helper method to define mock.On call
//   - key *ari.Key
//   - name string
//   - value string
func (_e *Channel_Expecter) SetVariable(key interface{}, name interface{}, value interface{}) *Channel_SetVariable_Call {
	return &Channel_SetVariable_Call{Call: _e.mock.On("SetVariable", key, name, value)}
}

func (_c *Channel_SetVariable_Call) Run(run func(key *ari.Key, name string, value string)) *Channel_SetVariable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Channel_SetVariable_Call) Return(err error) *Channel_SetVariable_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Channel_SetVariable_Call) RunAndReturn(run func(key *ari.Key, name string, value string) error) *Channel_SetVariable_Call {
	_c.Call.Return(run)
	return _c
}

// Silence provides a mock function for the type Channel
func (_mock *Channel) Silence(key *ari.Key) error {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Silence")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key) error); ok {
		r0 = returnFunc(key)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Channel_Silence_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Silence'
type Channel_Silence_Call struct {
	*mock.Call
}

// Silence is a helper method to define mock.On call
//   - key *ari.Key
func (_e *Channel_Expecter) Silence(key interface{}) *Channel_Silence_Call {
	return &Channel_Silence_Call{Call: _e.mock.On("Silence", key)}
}

func (_c *Channel_Silence_Call) Run(run func(key *ari.Key)) *Channel_Silence_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Channel_Silence_Call) Return(err error) *Channel_Silence_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Channel_Silence_Call) RunAndReturn(run func(key *ari.Key) error) *Channel_Silence_Call {
	_c.Call.Return(run)
	return _c
}

// Snoop provides a mock function for the type Channel
func (_mock *Channel) Snoop(key *ari.Key, snoopID string, opts *ari.SnoopOptions) (*ari.ChannelHandle, error) {
	ret := _mock.Called(key, snoopID, opts)

	if len(ret) == 0 {
		panic("no return value specified for Snoop")
	}

	var r0 *ari.ChannelHandle
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, string, *ari.SnoopOptions) (*ari.ChannelHandle, error)); ok {
		return returnFunc(key, snoopID, opts)
	}
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, string, *ari.SnoopOptions) *ari.ChannelHandle); ok {
		r0 = returnFunc(key, snoopID, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ari.ChannelHandle)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*ari.Key, string, *ari.SnoopOptions) error); ok {
		r1 = returnFunc(key, snoopID, opts)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Channel_Snoop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Snoop'
type Channel_Snoop_Call struct {
	*mock.Call
}

// Snoop is a helper method to define mock.On call
//   - key *ari.Key
//   - snoopID string
//   - opts *ari.SnoopOptions
func (_e *Channel_Expecter) Snoop(key interface{}, snoopID interface{}, opts interface{}) *Channel_Snoop_Call {
	return &Channel_Snoop_Call{Call: _e.mock.On("Snoop", key, snoopID, opts)}
}

func (_c *Channel_Snoop_Call) Run(run func(key *ari.Key, snoopID string, opts *ari.SnoopOptions)) *Channel_Snoop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 *ari.SnoopOptions
		if args[2] != nil {
			arg2 = args[2].(*ari.SnoopOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Channel_Snoop_Call) Return(channelHandle *ari.ChannelHandle, err error) *Channel_Snoop_Call {
	_c.Call.Return(channelHandle, err)
	return _c
}

func (_c *Channel_Snoop_Call) RunAndReturn(run func(key *ari.Key, snoopID string, opts *ari.SnoopOptions) (*ari.ChannelHandle, error)) *Channel_Snoop_Call {
	_c.Call.Return(run)
	return _c
}

// StageExternalMedia provides a mock function for the type Channel
func (_mock *Channel) StageExternalMedia(key *ari.Key, opts ari.ExternalMediaOptions) (*ari.ChannelHandle, error) {
	ret := _mock.Called(key, opts)

	if len(ret) == 0 {
		panic("no return value specified for StageExternalMedia")
	}

	var r0 *ari.ChannelHandle
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, ari.ExternalMediaOptions) (*ari.ChannelHandle, error)); ok {
		return returnFunc(key, opts)
	}
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, ari.ExternalMediaOptions) *ari.ChannelHandle); ok {
		r0 = returnFunc(key, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ari.ChannelHandle)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*ari.Key, ari.ExternalMediaOptions) error); ok {
		r1 = returnFunc(key, opts)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Channel_StageExternalMedia_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StageExternalMedia'
type Channel_StageExternalMedia_Call struct {
	*mock.Call
}

// StageExternalMedia is a helper method to define mock.On call
//   - key *ari.Key
//   - opts ari.ExternalMediaOptions
func (_e *Channel_Expecter) StageExternalMedia(key interface{}, opts interface{}) *Channel_StageExternalMedia_Call {
	return &Channel_StageExternalMedia_Call{Call: _e.mock.On("StageExternalMedia", key, opts)}
}

func (_c *Channel_StageExternalMedia_Call) Run(run func(key *ari.Key, opts ari.ExternalMediaOptions)) *Channel_StageExternalMedia_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		var arg1 ari.ExternalMediaOptions
		if args[1] != nil {
			arg1 = args[1].(ari.ExternalMediaOptions)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Channel_StageExternalMedia_Call) Return(channelHandle *ari.ChannelHandle, err error) *Channel_StageExternalMedia_Call {
	_c.Call.Return(channelHandle, err)
	return _c
}

func (_c *Channel_StageExternalMedia_Call) RunAndReturn(run func(key *ari.Key, opts ari.ExternalMediaOptions) (*ari.ChannelHandle, error)) *Channel_StageExternalMedia_Call {
	_c.Call.Return(run)
	return _c
}

// StageOriginate provides a mock function for the type Channel
func (_mock *Channel) StageOriginate(key *ari.Key, originateRequest ari.OriginateRequest) (*ari.ChannelHandle, error) {
	ret := _mock.Called(key, originateRequest)

	if len(ret) == 0 {
		panic("no return value specified for StageOriginate")
	}

	var r0 *ari.ChannelHandle
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, ari.OriginateRequest) (*ari.ChannelHandle, error)); ok {
		return returnFunc(key, originateRequest)
	}
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, ari.OriginateRequest) *ari.ChannelHandle); ok {
		r0 = returnFunc(key, originateRequest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ari.ChannelHandle)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*ari.Key, ari.OriginateRequest) error); ok {
		r1 = returnFunc(key, originateRequest)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Channel_StageOriginate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StageOriginate'
type Channel_StageOriginate_Call struct {
	*mock.Call
}

// StageOriginate is a helper method to define mock.On call
//   - key *ari.Key
//   - originateRequest ari.OriginateRequest
func (_e *Channel_Expecter) StageOriginate(key interface{}, originateRequest interface{}) *Channel_StageOriginate_Call {
	return &Channel_StageOriginate_Call{Call: _e.mock.On("StageOriginate", key, originateRequest)}
}

func (_c *Channel_StageOriginate_Call) Run(run func(key *ari.Key, originateRequest ari.OriginateRequest)) *Channel_StageOriginate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		var arg1 ari.OriginateRequest
		if args[1] != nil {
			arg1 = args[1].(ari.OriginateRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Channel_StageOriginate_Call) Return(channelHandle *ari.ChannelHandle, err error) *Channel_StageOriginate_Call {
	_c.Call.Return(channelHandle, err)
	return _c
}

func (_c *Channel_StageOriginate_Call) RunAndReturn(run func(key *ari.Key, originateRequest ari.OriginateRequest) (*ari.ChannelHandle, error)) *Channel_StageOriginate_Call {
	_c.Call.Return(run)
	return _c
}

// StagePlay provides a mock function for the type Channel
func (_mock *Channel) StagePlay(key *ari.Key, playbackID string, mediaURI ...string) (*ari.PlaybackHandle, error) {
	// string
	_va := make([]interface{}, len(mediaURI))
	for _i := range mediaURI {
		_va[_i] = mediaURI[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key, playbackID)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StagePlay")
	}

	var r0 *ari.PlaybackHandle
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, string, ...string) (*ari.PlaybackHandle, error)); ok {
		return returnFunc(key, playbackID, mediaURI...)
	}
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, string, ...string) *ari.PlaybackHandle); ok {
		r0 = returnFunc(key, playbackID, mediaURI...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ari.PlaybackHandle)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*ari.Key, string, ...string) error); ok {
		r1 = returnFunc(key, playbackID, mediaURI...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Channel_StagePlay_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StagePlay'
type Channel_StagePlay_Call struct {
	*mock.Call
}

// StagePlay is a helper method to define mock.On call
//   - key *ari.Key
//   - playbackID string
//   - mediaURI ...string
func (_e *Channel_Expecter) StagePlay(key interface{}, playbackID interface{}, mediaURI ...interface{}) *Channel_StagePlay_Call {
	return &Channel_StagePlay_Call{Call: _e.mock.On("StagePlay",
		append([]interface{}{key, playbackID}, mediaURI...)...)}
}

func (_c *Channel_StagePlay_Call) Run(run func(key *ari.Key, playbackID string, mediaURI ...string)) *Channel_StagePlay_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []string
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *Channel_StagePlay_Call) Return(playbackHandle *ari.PlaybackHandle, err error) *Channel_StagePlay_Call {
	_c.Call.Return(playbackHandle, err)
	return _c
}

func (_c *Channel_StagePlay_Call) RunAndReturn(run func(key *ari.Key, playbackID string, mediaURI ...string) (*ari.PlaybackHandle, error)) *Channel_StagePlay_Call {
	_c.Call.Return(run)
	return _c
}

// StageRecord provides a mock function for the type Channel
func (_mock *Channel) StageRecord(key *ari.Key, name string, opts *ari.RecordingOptions) (*ari.LiveRecordingHandle, error) {
	ret := _mock.Called(key, name, opts)

	if len(ret) == 0 {
		panic("no return value specified for StageRecord")
	}

	var r0 *ari.LiveRecordingHandle
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, string, *ari.RecordingOptions) (*ari.LiveRecordingHandle, error)); ok {
		return returnFunc(key, name, opts)
	}
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, string, *ari.RecordingOptions) *ari.LiveRecordingHandle); ok {
		r0 = returnFunc(key, name, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ari.LiveRecordingHandle)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*ari.Key, string, *ari.RecordingOptions) error); ok {
		r1 = returnFunc(key, name, opts)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Channel_StageRecord_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StageRecord'
type Channel_StageRecord_Call struct {
	*mock.Call
}

// StageRecord is a helper method to define mock.On call
//   - key *ari.Key
//   - name string
//   - opts *ari.RecordingOptions
func (_e *Channel_Expecter) StageRecord(key interface{}, name interface{}, opts interface{}) *Channel_StageRecord_Call {
	return &Channel_StageRecord_Call{Call: _e.mock.On("StageRecord", key, name, opts)}
}

func (_c *Channel_StageRecord_Call) Run(run func(key *ari.Key, name string, opts *ari.RecordingOptions)) *Channel_StageRecord_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 *ari.RecordingOptions
		if args[2] != nil {
			arg2 = args[2].(*ari.RecordingOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Channel_StageRecord_Call) Return(liveRecordingHandle *ari.LiveRecordingHandle, err error) *Channel_StageRecord_Call {
	_c.Call.Return(liveRecordingHandle, err)
	return _c
}

func (_c *Channel_StageRecord_Call) RunAndReturn(run func(key *ari.Key, name string, opts *ari.RecordingOptions) (*ari.LiveRecordingHandle, error)) *Channel_StageRecord_Call {
	_c.Call.Return(run)
	return _c
}

// StageSnoop provides a mock function for the type Channel
func (_mock *Channel) StageSnoop(key *ari.Key, snoopID string, opts *ari.SnoopOptions) (*ari.ChannelHandle, error) {
	ret := _mock.Called(key, snoopID, opts)

	if len(ret) == 0 {
		panic("no return value specified for StageSnoop")
	}

	var r0 *ari.ChannelHandle
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, string, *ari.SnoopOptions) (*ari.ChannelHandle, error)); ok {
		return returnFunc(key, snoopID, opts)
	}
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, string, *ari.SnoopOptions) *ari.ChannelHandle); ok {
		r0 = returnFunc(key, snoopID, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ari.ChannelHandle)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*ari.Key, string, *ari.SnoopOptions) error); ok {
		r1 = returnFunc(key, snoopID, opts)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Channel_StageSnoop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StageSnoop'
type Channel_StageSnoop_Call struct {
	*mock.Call
}

// StageSnoop is a helper method to define mock.On call
//   - key *ari.Key
//   - snoopID string
//   - opts *ari.SnoopOptions
func (_e *Channel_Expecter) StageSnoop(key interface{}, snoopID interface{}, opts interface{}) *Channel_StageSnoop_Call {
	return &Channel_StageSnoop_Call{Call: _e.mock.On("StageSnoop", key, snoopID, opts)}
}

func (_c *Channel_StageSnoop_Call) Run(run func(key *ari.Key, snoopID string, opts *ari.SnoopOptions)) *Channel_StageSnoop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 *ari.SnoopOptions
		if args[2] != nil {
			arg2 = args[2].(*ari.SnoopOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Channel_StageSnoop_Call) Return(channelHandle *ari.ChannelHandle, err error) *Channel_StageSnoop_Call {
	_c.Call.Return(channelHandle, err)
	return _c
}

func (_c *Channel_StageSnoop_Call) RunAndReturn(run func(key *ari.Key, snoopID string, opts *ari.SnoopOptions) (*ari.ChannelHandle, error)) *Channel_StageSnoop_Call {
	_c.Call.Return(run)
	return _c
}

// StopHold provides a mock function for the type Channel
func (_mock *Channel) StopHold(key *ari.Key) error {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for StopHold")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key) error); ok {
		r0 = returnFunc(key)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Channel_StopHold_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopHold'
type Channel_StopHold_Call struct {
	*mock.Call
}

// StopHold is a helper method to define mock.On call
//   - key *ari.Key
func (_e *Channel_Expecter) StopHold(key interface{}) *Channel_StopHold_Call {
	return &Channel_StopHold_Call{Call: _e.mock.On("StopHold", key)}
}

func (_c *Channel_StopHold_Call) Run(run func(key *ari.Key)) *Channel_StopHold_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Channel_StopHold_Call) Return(err error) *Channel_StopHold_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Channel_StopHold_Call) RunAndReturn(run func(key *ari.Key) error) *Channel_StopHold_Call {
	_c.Call.Return(run)
	return _c
}

// StopMOH provides a mock function for the type Channel
func (_mock *Channel) StopMOH(key *ari.Key) error {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for StopMOH")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key) error); ok {
		r0 = returnFunc(key)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Channel_StopMOH_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopMOH'
type Channel_StopMOH_Call struct {
	*mock.Call
}

// StopMOH is a helper method to define mock.On call
//   - key *ari.Key
func (_e *Channel_Expecter) StopMOH(key interface{}) *Channel_StopMOH_Call {
	return &Channel_StopMOH_Call{Call: _e.mock.On("StopMOH", key)}
}

func (_c *Channel_StopMOH_Call) Run(run func(key *ari.Key)) *Channel_StopMOH_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Channel_StopMOH_Call) Return(err error) *Channel_StopMOH_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Channel_StopMOH_Call) RunAndReturn(run func(key *ari.Key) error) *Channel_StopMOH_Call {
	_c.Call.Return(run)
	return _c
}

// StopRing provides a mock function for the type Channel
func (_mock *Channel) StopRing(key *ari.Key) error {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for StopRing")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key) error); ok {
		r0 = returnFunc(key)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Channel_StopRing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopRing'
type Channel_StopRing_Call struct {
	*mock.Call
}

// StopRing is a helper method to define mock.On call
//   - key *ari.Key
func (_e *Channel_Expecter) StopRing(key interface{}) *Channel_StopRing_Call {
	return &Channel_StopRing_Call{Call: _e.mock.On("StopRing", key)}
}

func (_c *Channel_StopRing_Call) Run(run func(key *ari.Key)) *Channel_StopRing_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Channel_StopRing_Call) Return(err error) *Channel_StopRing_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Channel_StopRing_Call) RunAndReturn(run func(key *ari.Key) error) *Channel_StopRing_Call {
	_c.Call.Return(run)
	return _c
}

// StopSilence provides a mock function for the type Channel
func (_mock *Channel) StopSilence(key *ari.Key) error {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for StopSilence")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key) error); ok {
		r0 = returnFunc(key)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Channel_StopSilence_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopSilence'
type Channel_StopSilence_Call struct {
	*mock.Call
}

// StopSilence is a helper method to define mock.On call
//   - key *ari.Key
func (_e *Channel_Expecter) StopSilence(key interface{}) *Channel_StopSilence_Call {
	return &Channel_StopSilence_Call{Call: _e.mock.On("StopSilence", key)}
}

func (_c *Channel_StopSilence_Call) Run(run func(key *ari.Key)) *Channel_StopSilence_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Channel_StopSilence_Call) Return(err error) *Channel_StopSilence_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Channel_StopSilence_Call) RunAndReturn(run func(key *ari.Key) error) *Channel_StopSilence_Call {
	_c.Call.Return(run)
	return _c
}

// Subscribe provides a mock function for the type Channel
func (_mock *Channel) Subscribe(key *ari.Key, n ...string) ari.Subscription {
	// string
	_va := make([]interface{}, len(n))
	for _i := range n {
		_va[_i] = n[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Subscribe")
	}

	var r0 ari.Subscription
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, ...string) ari.Subscription); ok {
		r0 = returnFunc(key, n...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ari.Subscription)
		}
	}
	return r0
}

// Channel_Subscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Subscribe'
type Channel_Subscribe_Call struct {
	*mock.Call
}

// Subscribe is a helper method to define mock.On call
//   - key *ari.Key
//   - n ...string
func (_e *Channel_Expecter) Subscribe(key interface{}, n ...interface{}) *Channel_Subscribe_Call {
	return &Channel_Subscribe_Call{Call: _e.mock.On("Subscribe",
		append([]interface{}{key}, n...)...)}
}

func (_c *Channel_Subscribe_Call) Run(run func(key *ari.Key, n ...string)) *Channel_Subscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		var arg1 []string
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *Channel_Subscribe_Call) Return(subscription ari.Subscription) *Channel_Subscribe_Call {
	_c.Call.Return(subscription)
	return _c
}

func (_c *Channel_Subscribe_Call) RunAndReturn(run func(key *ari.Key, n ...string) ari.Subscription) *Channel_Subscribe_Call {
	_c.Call.Return(run)
	return _c
}

// Unmute provides a mock function for the type Channel
func (_mock *Channel) Unmute(key *ari.Key, dir ari.Direction) error {
	ret := _mock.Called(key, dir)

	if len(ret) == 0 {
		panic("no return value specified for Unmute")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, ari.Direction) error); ok {
		r0 = returnFunc(key, dir)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Channel_Unmute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unmute'
type Channel_Unmute_Call struct {
	*mock.Call
}

// Unmute is a helper method to define mock.On call
//   - key *ari.Key
//   - dir ari.Direction
func (_e *Channel_Expecter) Unmute(key interface{}, dir interface{}) *Channel_Unmute_Call {
	return &Channel_Unmute_Call{Call: _e.mock.On("Unmute", key, dir)}
}

func (_c *Channel_Unmute_Call) Run(run func(key *ari.Key, dir ari.Direction)) *Channel_Unmute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		var arg1 ari.Direction
		if args[1] != nil {
			arg1 = args[1].(ari.Direction)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Channel_Unmute_Call) Return(err error) *Channel_Unmute_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Channel_Unmute_Call) RunAndReturn(run func(key *ari.Key, dir ari.Direction) error) *Channel_Unmute_Call {
	_c.Call.Return(run)
	return _c
}

// UserEvent provides a mock function for the type Channel
func (_mock *Channel) UserEvent(key *ari.Key, ue *ari.ChannelUserevent) error {
	ret := _mock.Called(key, ue)

	if len(ret) == 0 {
		panic("no return value specified for UserEvent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*ari.Key, *ari.ChannelUserevent) error); ok {
		r0 = returnFunc(key, ue)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Channel_UserEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UserEvent'
type Channel_UserEvent_Call struct {
	*mock.Call
}

// UserEvent is a helper method to define mock.On call
//   - key *ari.Key
//   - ue *ari.ChannelUserevent
func (_e *Channel_Expecter) UserEvent(key interface{}, ue interface{}) *Channel_UserEvent_Call {
	return &Channel_UserEvent_Call{Call: _e.mock.On("UserEvent", key, ue)}
}

func (_c *Channel_UserEvent_Call) Run(run func(key *ari.Key, ue *ari.ChannelUserevent)) *Channel_UserEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ari.Key
		if args[0] != nil {
			arg0 = args[0].(*ari.Key)
		}
		var arg1 *ari.ChannelUserevent
		if args[1] != nil {
			arg1 = args[1].(*ari.ChannelUserevent)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Channel_UserEvent_Call) Return(err error) *Channel_UserEvent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Channel_UserEvent_Call) RunAndReturn(run func(key *ari.Key, ue *ari.ChannelUserevent) error) *Channel_UserEvent_Call {
	_c.Call.Return(run)
	return _c
}
